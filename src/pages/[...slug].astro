---
import { getCollection, type CollectionEntry } from "astro:content";
import Page from "../templates/Page.astro";
import Contact from "../templates/Contact.astro";
import List from "../templates/List.astro";
// import Elements from '../templates/Elements.astro';

export async function getStaticPaths() {
  const pages = await getCollection("pages");

  const workEntries = await getCollection("work");
  type SortableEntry = CollectionEntry<"work">;
  const sortDate = (a: SortableEntry, b: SortableEntry) =>
    new Date(b.data.date || 0).getTime() - new Date(a.data.date || 0).getTime();
  const sortedWork = workEntries.sort(sortDate);

  return pages
    .filter((entry) => entry.slug !== "index" && entry.slug !== "news" && entry.slug !== "sold")
    .map((entry) => {
      let props = { entry };
      let items: SortableEntry[] = [];
      let baseSlug = "";

      if (entry.data.templateKey === "work-page") {
        items = sortedWork;
        baseSlug = "work";
      }

      return {
        params: { slug: entry.slug === "index" ? undefined : entry.slug },
        // If slug is 'index', it creates undefined path, which matches root '/'.
        // BUT we have src/pages/index.astro, which takes precedence.
        // So this route will NOT handle root.
        // Wait, getStaticPaths params: { slug: undefined } works for [...slug] to match root?
        // Yes, but index.astro (file) > [...slug].astro (dynamic).
        // So it's safe.
        // For 'bio', slug is 'bio'.
        props: { ...props, items, baseSlug },
      };
    });
}

const { entry, items, baseSlug } = Astro.props;
const templateKey = entry.data.templateKey;
---

{
  templateKey === "contact-page" ? (
    <Contact entry={entry} />
  ) : templateKey === "work-page" ? (
    <List entry={entry} items={items} baseSlug={baseSlug} />
  ) : (
    <Page entry={entry} />
  )
}
